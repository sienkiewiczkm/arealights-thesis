\documentclass[../main.tex]{subfiles}

\begin{document}
\chapter{Metoda Monte Carlo}

Równanie renderingu (ang. \textit{render equation}) ma postać:

$$
L_o(\omega_o) = \int_{\Omega} {
    L(\omega_{l})
    f_r(\omega_{v}, \omega_{l})
    \cos \theta_{l}
    d\omega_{l}
}
$$

Większość obecnie produkowanych silników do gier używa uproszczenia
polegającego na zastosowaniu świateł punktowych, stąd natężenie światła
przychodzącego jest niezerowe tylko w kierunkach będących znormalizowanymi
wektorami między oświetlanym punktem a każdym z aktywnych świateł w scenie.
Powoduje to redukcję całki równania oświetlenia do sumy skończonej:

$$ L_o = \sum_{l \in L} L(\omega_l) f_r(\omega_v, \omega_l)\cos \theta_l $$

Obliczenie powyższej sumy, nie jest wyzwaniem dla obecnych kart graficznych
nawet dla większej liczby świateł, szczególnie przy zastosowaniu specjalnych
technik zmniejszających wymaganą liczbę operacji do minimum, np.
\textit{deferred shading}.

W przypadku świateł zajmujących ciągły fragment dziedziny sferycznej, całka nie
może zostać w bezpośredni sposób uproszczona do postaci sumy skończonej bez
utraty dokładności. Niestety również dla większośći funkcji $L$, $\rho$
rozwiązanie dokładne nie będzie możliwe do znalezienia w ograniczonym czasie
wymaganym do zachowania płynności aplikacji.

Metody przybliżające wartość całki zostaną opisane w kolejnych rozdziałach,
jednak wiedza na temat rozwiązania dokładnego przyda nam się do zrozumienia
kolejnych metod.

\section{Metoda Monte Carlo}

Całkowanie funkcji renderingu

$$
\int{
    L_i(l)
    \rho(l,v)
    \cos \theta_{l}
    \: dl
} $$

nie jest prostym zadaniem do wykonania. Z pomocą przychodzi metoda przybliona
Monte Carlo bazująca na rachunku prawdopodobieństwa i prawie wielkich liczb.

Metoda dokładnie opisana jest w publikacjach \cite{MonteCarloAnderson}
\cite{Veach}.

\todo[inline]{Definicje zmiennych losowych? Może to przesada.}

Definicja dystrybuanty (ang. \textit{cumulative distribution function},
\textit{CDF}):

$$
P(x) = Pr \{ X \leq x \}
$$

Definicja funkcji gęstości prawopodobieństwa (ang. \textit{probability density
function}, \textit{PDF}):

$$
f_{X}(x) = \frac{dP}{dx}(x)
$$

Weżmy funkcję gęstości prawdopobieństwa $f_X$ ciągłej zmiennej losowej $X$.
Wartość oczekiwana funkcji $g$ na ciągłej zmiennej losowej $X$ wynosi:

$$
\mathbf{E}(g(x)) =
\int_{X}{
    g(x) f_{X}(x)
    \:dx
}
$$

Estymatorem Monte Carlo przybliżającym wartość $\mathbb{E}(g(x))$ nazywamy:

$$
\widetilde{g_n}(x) =
    \frac{1}{n}
    \sum_{i=1}^{n}g(x_i)
$$

gdzie, $x=(x_1, \ldots, x_n)$ jest zbiorem $n$ próbek zmiennej losowej $X$.

\section{Metoda iteracyjna}

Metoda Monte-Carlo ze względu na swoją złożoność obliczeniową nie umożliwia
uzyskania rezultatu w czasie rzeczywistym. Możliwość operowania sceną,
precyzyjnego ustawienia kamery i obiektów nie jest łatwe w takim środowisku.
Czasami nie potrzebujemy również bardzo dużej szczegółowości, czasem wystarczy
nam konkretna ilość iteracji do znalezienia problemu i głównych różnic.

Wygodnym komromisem jest podzielenie obliczeń na wiele etapów, z których każdy
może zostać wyświetlony jako częściowy podgląd.

Spróbujmy zbudować ciąg podsum Monte-Carlo:

$$
I_n = \frac{1}{n} \sum_{i=1}^{n} f(x_i)
$$
$$
I_{n+1} = \frac{1}{n+1} \sum_{i+1}^{n+1}f(x_i)
= \frac{n}{(n+1)n} \sum_{i=1}^{n}f(x_i) + \frac{1}{n+1}f(x_{n+1})
= \frac{n}{n+1} I_{n} + \frac{1}{n+1}f(x_{n+1})
$$

Dodatkowy czas potrzebny na przygotowanie ramki, policzenie sumy ważonej
i wyświetlenie rezultatu na ekranie sprawia, że uzyskamy szybszą zbieżność bez
zauważalnego spadku wydajności przez zgrupowanie próbkek w pakiety, które mogą
zostać potencjalnie policzone jednocześnie. Okazuje się, że rozpisanie
analogicznego równania dla paczek danego, stałego rozmiaru jest trywialny:

\begin{align*}
  I_{(m+1)n} &= \frac{1}{(m+1)n} \sum_{i=1}^{(m+1)n} f(x_i)
  = \frac{1}{(m+1)n} \sum_{i=1}^{mn} f(x_i)
    + \frac{1}{(m+1)n} \sum_{i=mn+1}^{(m+1)n} f(x_i) = \\
  &= \frac{m}{(m+1)mn} \sum_{i=1}^{mn} f(x_i)
    + \frac{1}{(m+1)n} \sum_{i=mn+1}^{(m+1)n} f(x_i) \\
  &= \frac{m}{m+1}I_{mn}
    + \frac{1}{m+1} \left(
        \frac{1}{n} \sum_{i=mn+1}^{(m+1)n} f(x_i)
    \right)
\end{align*}

Powyższe obliczenie sumy ważonej może zostać zrealizowane za pomocą sprytnie
zbudowanego łańcucha \textit{framebufferów} i obliczone za pomocą wspartego
sprzętowo mechanizmu łączenia kolorów (ang. \textit{blending}). Obecna partia
musi zostać obliczona do jednego z buforów oraz skopiowana z włączonym
mieszaniem kolorów do drugiego bufora. Można zastosować uproszczenie, w którym
wykorzystamy tylko jeden bufor, ale czasami ze względu na istnienie wielu
świateł i wybraną technikę (np. \textit{deferred shading}) może być koniecznie
zastosowanie dwóch buforów.

\section{Importance Sampling}

\todo[inline]{Napisać coś o Importance Samplingu, źródła: Veach, MC Stamford notes}

\subsection{Multi-sample model}
\subsection{Balance heuristics}

\section{Low-discrepancy sequence}

Ciągi o niskim \fbox{\textit{discrepancy}} są bardzo istotne w generowaniu
próbek używanych do importance samplingu.

\subsection{Halton sequence}
\subsection{Hammersley set}

\end{document}
